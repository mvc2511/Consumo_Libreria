{"ast":null,"code":"import { TextEncoder } from 'util';\nimport { Readable } from 'stream';\nimport utils from \"../utils.js\";\nimport readBlob from \"./readBlob.js\";\nconst BOUNDARY_ALPHABET = utils.ALPHABET.ALPHA_DIGIT + '-_';\nconst textEncoder = new TextEncoder();\nconst CRLF = '\\r\\n';\nconst CRLF_BYTES = textEncoder.encode(CRLF);\nconst CRLF_BYTES_COUNT = 2;\nclass FormDataPart {\n  constructor(name, value) {\n    const {\n      escapeName\n    } = this.constructor;\n    const isStringValue = utils.isString(value);\n    let headers = `Content-Disposition: form-data; name=\"${escapeName(name)}\"${!isStringValue && value.name ? `; filename=\"${escapeName(value.name)}\"` : ''}${CRLF}`;\n    if (isStringValue) {\n      value = textEncoder.encode(String(value).replace(/\\r?\\n|\\r\\n?/g, CRLF));\n    } else {\n      headers += `Content-Type: ${value.type || \"application/octet-stream\"}${CRLF}`;\n    }\n    this.headers = textEncoder.encode(headers + CRLF);\n    this.contentLength = isStringValue ? value.byteLength : value.size;\n    this.size = this.headers.byteLength + this.contentLength + CRLF_BYTES_COUNT;\n    this.name = name;\n    this.value = value;\n  }\n  async *encode() {\n    yield this.headers;\n    const {\n      value\n    } = this;\n    if (utils.isTypedArray(value)) {\n      yield value;\n    } else {\n      yield* readBlob(value);\n    }\n    yield CRLF_BYTES;\n  }\n  static escapeName(name) {\n    return String(name).replace(/[\\r\\n\"]/g, match => ({\n      '\\r': '%0D',\n      '\\n': '%0A',\n      '\"': '%22'\n    })[match]);\n  }\n}\nconst formDataToStream = (form, headersHandler, options) => {\n  const {\n    tag = 'form-data-boundary',\n    size = 25,\n    boundary = tag + '-' + utils.generateString(size, BOUNDARY_ALPHABET)\n  } = options || {};\n  if (!utils.isFormData(form)) {\n    throw TypeError('FormData instance required');\n  }\n  if (boundary.length < 1 || boundary.length > 70) {\n    throw Error('boundary must be 10-70 characters long');\n  }\n  const boundaryBytes = textEncoder.encode('--' + boundary + CRLF);\n  const footerBytes = textEncoder.encode('--' + boundary + '--' + CRLF + CRLF);\n  let contentLength = footerBytes.byteLength;\n  const parts = Array.from(form.entries()).map(([name, value]) => {\n    const part = new FormDataPart(name, value);\n    contentLength += part.size;\n    return part;\n  });\n  contentLength += boundaryBytes.byteLength * parts.length;\n  contentLength = utils.toFiniteNumber(contentLength);\n  const computedHeaders = {\n    'Content-Type': `multipart/form-data; boundary=${boundary}`\n  };\n  if (Number.isFinite(contentLength)) {\n    computedHeaders['Content-Length'] = contentLength;\n  }\n  headersHandler && headersHandler(computedHeaders);\n  return Readable.from(async function* () {\n    for (const part of parts) {\n      yield boundaryBytes;\n      yield* part.encode();\n    }\n    yield footerBytes;\n  }());\n};\nexport default formDataToStream;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}